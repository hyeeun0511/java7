// [메서드]          
// : () 필수 => 메소드()
// ex) void println() => println:메서드
// 호출 방법 : 참조변수.메서드 이름()
// 클래스 메서드 : 객체선언X 사용가능
// 인스턴스 메서드 : 객체선언O 해야 사용가능 / static붙어있을때 > 객체선언X이어도 사용가능
// 추상메서드 : 
// ======================================================
// ==============================================
// # 추상클래스 (abstract class) 
// : 추상메소드를 한개이상 갖고있는 클래스
//    -> 추상메소드 : {}가 없음 ex.~();
// : final, static
// - 미완성된 메소드(설계도)를 포함하는 클래스
// - 완성 메소드 -> ex_ void play() {}
// - 미완성 메소드 -> ex_ void play(); -> 중괄호가 없음
// abstract : void앞, class앞에 붙여줘야함
// - 상속해서(extends -) 완성시켜야만 객체선언 가능
// - 상속받은 이름을 사용하지않으면 에러 (상속받으면 무조건 사용하도록 되어있음)
// 사용 이유
// 1) 이름의 통일성
// 2) 중요한 메서드를 반드시 구현하도록 강제
//==============================================
// # 추상메서드 
// - 선언부(구현하는 부분)만 있고 구현부(body)가 없는 메서드
// - 하나만 있어도 추상클래스
//==============================================
// # 인터페이스
// - 추상클래스(미완성 설계도)보다 추상화정도가 높음 - 추상클래스
// - 실제 구현된 것이 전혀 없는 기본 설계도
// - 추상메서드, 상수만 갖을 수 있음
// - 인스턴스 생성 불가XXX, 객체선언 불가XXX
// - 상속만 가능
// - 목적 : 상속을 만들기 위해서
// - 형태 : interface 인터페이스명 { 
//             public static final 상수; -> 생략가능
//             public abstract 메서드;    -> 생략가능
//         }
// - 새 파일 만들때 -> Class 생성이 아닌, Interface 생성
// - 사용방법 : 상속해서 사용 (implements 인터페이스명)
// - 다중상속 가능
// - object 클래스 상속X -> extends Object 붙이지 않음XXX
// - 인터페이스를 구현 받을때는 implements 사용
//   -> 상속받는 형태 : interface 인터페이스명 {} 
// - 장점 : 개발시간 ↓, 표준화 가능, 관계 클래스들 관계 맺어줌, 확장성
// - interface -> interface ~ extends ~{}
// - class -> 클래스이름 implements 인터페이스이름{}
// ======================================================
// ======================================================
// [메서드 오버로딩]  == 중요!!!
// 오버로딩 
// : 메서드 이름이 같고, 매개변수의 개수 또는 타입이 다른 것
// int add(int a, int b) {return a+b};
// int add(int x, int y) {return x+y};  // 안됨
// 리턴타입과 상관X
// - 메서드 이름이 같아도 매개변수의 개수 또는 타입이 다르면 가능 
// - 정의가 한개라도 다르면 오버로딩
// ======================================================
// # 생성자 
// : 초기화 매서드
// [ 생성자의 조건 ]
// 1) 생성자의 이름 = 클래스명이 같다
// 2) 메서드. ()
// 3) void X없음 = return값이 없음
// 4) return X없음
// 5) 생성자는 여러개 만들 수 있다 = 오버로딩 가능
// 생성자 안에있는것 - 변수X
// *부모에 기본생성자 없으면 오류남
// ======================================================
// [this]
// this() : 생성자에서 다른 생성자 호출
// this. : 인스턴스 변수
// 인스턴스변수와 지역변수를 구별하기위해 참조변수 this 사용
// ======================================================
// [변수] 
// 같은 이름 사용 불가
// 1. 클래스 내에 있을 경우
//   1) 클래스 변수
//      - 반드시 static을 넣어줘야함
//      - ＇클래스명.변수명'
//      - 객체선언(인스턴스생성) 없이 사용
//      - 공용으로 사용
//      - static int cv;
//   2) 인스턴스변수 {}
// 2. 메서드 내에 있을 경우
//   3) 지역변수 
//      - 자동 초기화 X -> 수동 초기화 시켜줘야함
// class명,  참조변수, 생성자
// Card c   = new   cored;
// ======================================================
// - 2. 인스턴스변수 (int iv;)  (void,
// 사용방법
// :　객체선언(new)(:인스턴스생성) 후 사용
// : 객체선언
// :　‘참조변수명.인스턴스변수명’으로 사용
// 각각 있는 것
// 인스턴스, 클래스 메서드 호출 가능
//
//
// [메서드 영역] - 메서드 : (반복적인) 코드 양↓, 코드 관리 쉬움
//      - 메서드 : return을 만나면 끝남
//
// - 3. 지역변수
// 메서드 내에 선언
// 조건물,반복문{} 벗어나면 사라짐*
// 초기화 X
//
//
//
// * 객체선언 = 객체생성 = 인스턴스선언
//
//
//
// void power() -> return타입이 없을 때 반드시 작성
//
// * 메서드 호출방법 
// 참조변수.메서드 이름();             - 메서드에 선언된 매개변수 X경우
// 참조변수.메서드 이름(값1, 값2, ...);   - 메서드에 선언된 매개변수 O경우
//
// *FILO : 나중에 들어온게 가장 마지막에 나감
// *FIFO : 나중에 들어온게 가장 먼저 나감
//
// *기본형 매개변수
// -> 1개만 리턴 가능
// *참조변수
// -> 1개 이상 리턴 가능
//
// # 재귀호출
// - 자기자신을 호출하는것
// ======================================================
// class -> main 으로 접근 => 1) retyrn 2) 참조변수::메서드 이름();
//
// * 매개변수로 보내는 방법
// 1) 기본형 매개변수 : return
// 2) 참조형 매개변수 : 참조변수::메서드 이름();
// ======================================================
// 초기화 블럭
// 클래스 초기화 블럭 : static {}
// 인스턴스 초기화 블럭 : {}
// ======================================================
// 프로그램 실행순서
// 1) static 먼저 실행
// 2) main 실행
// --- 클래스 초기화 블럭 실행 (기본값,명시적 초기화,클래스 초기화 블럭)->객체선언X
// 3) 인스턴스 초기화 블럭 실행
// ======================================================
// # 상속
// - 형태 : extends + 클래스명
// - 객체선언 필요 X
// - 기존의 클래스를 재사용해서 새로운 클래스 작성
// - 두 클래스를 조상과 자손으로 관계를 맺어줌 (조상이 다른 자손들은 서로 영향을 미치지않음)
// - 자손은 조상의 모든 멤버(변수,메서드)를 상속받음
// - 자손의 맴버개수는 조상의 맴버개수보다 많거나 같음(적을 수 없음)
// - 형변환은 시키면 되긴함 (실행시 -> 에러)
// - 조상의 변경 : 자손에 영향을 미침O / 자손의 변경 : 조상에 영향 X
// - java는 단일 상속만 지원 (다중 상속 X)
// - 또 상속 받고싶을 경우 -> 객체선언(형태:참조변수.클래스명)
// - 상속보다 객체선언 써도 됨 -> 다중상속의 문제점 해결 가능
// - 장점 : 코드 재사용성 증가, 코드의 추가 작성이 필요 없음, 유지보수가 용이
// - 단점 : 조상 클래스가 변경되면 자손 클래스에 영향, 불필요한 멤버까지 상속
// - 형태 : calss 자손클래스 extends 조상클래스
// - object 클래스를 모든 클래스의 조상으로 사용(모든 클래스의 조상 : object)(object를 자동으로 상속받음)
// - 상송X : 생성자, 초기화블럭
//==============================================
// # 상속 / 객체선언
// 상속 / 객체선언 : 선택해서 사용
// 업그레이드 -> 상속관계로 / 나머지는 객체선언
//==============================================
// # Deck 클래스
// main과 Deck 클래스 분리 -> 코드 관리 쉬움
// 입력 -> input()
// 출력 -> print()
// 검색 -> search()
// 수정 -> update()
//==============================================
// # 오버라이딩
// 상속일때만 가능 : extends
// : 조상클래스로부터 상속받은 메서드의 내용을 "상속받는 클래스"에 맞게 "변경"하는 것
// : 상속관계에서 조상의 메서드를 자손이 재정의(변경)하는 것
// : 메서드를 재정의하는 것
// - 상속받기 전 메서드와 이름, 매개변수, 리턴타입 모두 똑같아야함
// - 명령어를 변경할 필요 없음
// - 조건 : 모든 이름이 같아야함, 상속관계여야함
// - 상속일때만 똑같은 메서드 (오버로딩 : 이름은 같지만 매개변수 또는 타입이 다름)
//=============================================
// # 오버로딩/오버라이딩
// 공통점 : 메서드 이름이 같다 
// 차이점 : 오버로딩 - 매개변수의 개수 또는 타입이 다름 / 다른 메서드인데 이름만 같음
//        오버라이딩 - 상속관계일때, "타입, 이름, 매개변수" 동일함 / 같은 메서드
//==============================================
// [super]
// this와 같음. 조상의 멤버와 자신의 멤버를 구별하기 위해 사용
// - super() : 조상의 생성자 호출
// - super. : 조상의 인스턴스변수
// 구분 : this - 자신의 인스턴스변수 / super - 조상의 인스턴스변수
// 상속이 없을때 -> extends Object : super() / compiler가 자동으로 붙여줌
//==============================================
// [자동] 
// 안만들어주면 자동으로 생성됨
// 1) 기본생성자 : 생성자가 없으면 자동으로 붙여줌
// 2) extends object : extends가 없으면 자동으로 붙여줌
// 3) super(); : super();를 자동으로 붙여줌
// 4) 패키지 : package가 없으면 자동으로 붙여줌
//==============================================
// [실행 순서]
// 1) main() 메서드가 있는 클래스 
// 2) 조상 클래스
// 3) 생성자
//==============================================
// [패키지]
// 폴더 -> 관리하기 쉽도록 폴더로 구분(그룹화)
// java.lang.String
// 패키지 패키지 클래스(첫글자 대문자)
// 패키지 : 첫글자 소문자 / 클래스 : 첫글자 대문자
//=============================================
// import문 선언하는 방법
// 1) package명
// 2) import 패키지명.클래스명;
// 3) import 패키지명.*;  : 해당 패키지의 모든 클래스
// ==============================================
// # 제어자
// 1. 접근 제어자 
// public, protected(같은 클래스,같은 패키지, 자손클래스), default(같은 클래스,캍은 패키지), private(같은 클래스)
// public : 접근 제한 없음 (전체)
// protected : 같은 패키지 내에서 + 다른 패키지의 자손클래스에서 접근 가능
// default : 같은 클래스, 같은 패키지 내에서만 접근 가능
// private : 같은 클래스 내에서만 접근 가능
// 2. 그 외의 제어자
// static, final-상수, abstract-추상, ...
// final 사용될수있는 곳 : 클래스, 메서드, 멤버변수, 지역변수 => 값 변경 불가
//      -> 클래스 : 상속 불가 , 메서드 : 오버라이딩 불가 , 멤버변수/지역변수 : 값 변경 불가
// ==============================================
// # 캡슐화 
// : 데이터 은닉화 + 접근자 메서드(getter/setter)
// ==============================================
// # singleton 패턴
// 객체선언 없이 사용 -> static 붙여야함
// ==============================================
// # 다형성
// : 조상(부모)의 참조변수로 자손의 객체를 다루는 것
// : 상속일때

//==============================================
// # 자동 메서드 생성
// 1. 접근 제어자 
// public, protected(같은 클래스,같은 패키지, 자손클래스), default(같은 클래스,캍은 패키지), private(같은 클래스)
//==============================================
// # 프로그램 오류
// 1. 컴파일 에러 - 컨파일할 때 발생하는 에러
// 2. 런타임 에러 - 실행할 때 발생하는 에러
// 에러 : 코드에 의해 수습될 수 없는 심각한 오류 (개발자가 오류냄)
// 예외 : 코드에 의해 수습될 수 있는 다소 미약한 오류(내가 잘 했지만 외부랑 연결시키다가 외부에 연결시킴)
// 예외처리구문 : try{}catch(){}문 사용
//            -> if{}else{}문과 비슷함
// <예외처리구문>
// - try{}catch(){}문
// - 에러가 발생할 가능성이 있는 코드를 미리 감싸놓음
// - 0/0 : 에러
// - try문 전에 System.out.println(0/0); => try로 넘어가지않고 이전에서 멈춤
// - throw new Exception : 강제 에러 발생
// - e.printStackTrace(); : 에러발생 정보 위치 메세지 출력 !!많이사용!!
//                          미작성시 -> 에러 발생 위치 알수 없음
// - RuntimeException클래스 : 검사하지 않는 예외
// - Exception 클래스 : 컴파일 시점에 예외 처리 여부를 검사하는 예외
//
// - deleteTempFiles() : 파일이 저장돼도,저장되다 에러가나도 임시파일들을 삭제함
// - FileReader fr = new FileReader("c:/aaa/a1.txt"); 파일 연결
//----------------------------------------------
//  try-exception 하는 경우
//  1) db접속
//  2) 입출력
//  3) file처리
//==============================================
// # 오라클 DB & 자바 연결
//   -> 자바 프로그램이 oracle db와 통신할수 있게 만드는 과정
// 1. 파일 주소 복사
//    내PC > C드라이브 > oracle21 > dbhomeXE > jdbc > lib > ojdbc8.jar
// 2. Confiqure Build Path
//    eclipse 폴더 j0000 우클릭 > Build Path > Confiqure Build Path
// 3. apply
//    Properties for j0000 창 뜸 > Libraries > Classpath > Add External JARs... > Apply and Close
// 4. j0000 폴더 > Referenced Libraries > ojdbc8.jar
//==============================================
// # 메서드에 예외 선언        
// class > main >
// try-catch문으로 연결 

//==============================================
// # Object 클래스
// - 모든 클래스의 최상위 부모 클래스
// - 모든 클래스는 자동으로 extends Object를 상속받음
// - Object 클래스의 메서드는 모든 클래스에서 사용 가능
//
// [ Object 주요 메서드 ]
// 1. equals(Object obj)
//    - 객체 비교 메서드
//    - Object 기본 동작은 주소 비교 (==)
//    - 보통 내용 비교를 위해 오버라이딩해서 사용
//    - equals : 같다
//    - contains : 포함하다
//
// 2. hashCode()
//    - 객체를 식별하는 정수값
//    - equals()를 오버라이딩하면 반드시 함께 오버라이딩
//    - HashMap, HashSet에서 사용
//
// 3. clone()
//    - 객체를 복제해서 새로운 객체 생성
//    - 얕은 복사(Shallow Copy)
//    - implements Cloneable 인터페이스 필요
//    - CloneNotSupportedException 발생 가능
//    - 인스턴스 변수만 복제 가능 (참조형은 주소 복사)
//
// 4. getClass()
//    - 객체가 속한 클래스 정보를 담은 Class 객체 반환
//    - 클래스의 모든 정보를 가지고 있음
// ==============================================
// # 클래스 생성 시 자동 포함되는 요소
// 1. package 선언
// 2. extends Object (생략되어 있음)
// ==============================================
// # String 클래스
// - 문자열을 다루는 클래스
// - 내부적으로 char[] 배열 사용
// - 불변 객체(immutable)
// - 문자열 변경 시 새로운 객체 생성
//
// ex)
// String s = "abc";
// s = s + "d";  // 새로운 객체 생성
// ==============================================
// # Thread (스레드)
//
// 1. Single Thread
//    - 하나의 작업이 끝난 후 다음 작업 실행
//    - A 끝 → B 끝 → C 끝
//
// 2. Multi Thread
//    - 여러 작업을 번갈아 실행
//    - A 조금 → B 조금 → C 조금 → A 조금 → ...
// ==============================================
// # 빈 문자열("",empty string) 
// -String str=""; 가능 O
// -char c=""; 불가능 X
// 
// 
// 
//===============================================
//===============================================
// [ contains() 함수 ] 
// : 포함하는 것
// name[i].contains("순") -> "순"이 포함되어있는 이름
// name[i].equals("이순신") -> "이순신"과 똑같은 이름
//                            김이순신 -> 찾지않음. 
// >> contains : 포함된것 / equals : 같은것
//===============================================
// [ indexOf() 함수 사용 ]  -<문자 위치 찾기>-
// 1) 문자 선언
// 2) 문자 길이
// 3) for문
//===============================================
// [ trim() , replace() - 공백제거 ]
// trim() : 앞뒤 빈공백 제거  
//          중간(사이) 공백 제거 불가
// replace() : 문자 대체
//             (" ","") : 공백제거 (공백을 없애는걸로 대체)
//===============================================
// # 분리 (split)
// split(",") : 특정문자분리
// valueOf-타입변경, parseInt-타입변경
//===============================================
// # 문자열 > 기본형 값으로 변환하는 방법 
// Integer.parseInt()  // 대부분 이렇게 사용
// Integer.valueOf()
//===============================================
// # 문자열 자르기 (subString)
// subString(시작위치,끝위치)
// 시작위치부터 끝위치까지 자름
// - charAt() - 문자 1개 자름
//===============================================
// # String 클래스 
// - String, StringBuffer
// 1) String
//    : 숫자를 문자열로 이어 붙임 (누적해서 더하는것 X)
//===============================================
// # wrapper 클래스
// : 기본형 데이터를 객체로 감싸기 위한 클래스
// > 자바는 객체만 다루는 경우 많음↑ > 기본형을 객체처럼 사용하기위해
// - 내부적으로 기본형 변수를 갖고있음
// 첫글자만 대문자로 바뀜 
//     기본형 -> 래퍼클래스 
// ex) char -> Caracter
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//==============================================
// [ 학생 성적 처리 ] 
// * C08.java / Stuscore.java / stuDeck.java
// 1> Stuscore 클래스 정의
//   1) 인스턴스 초기화 블럭 생성 -> 학생수 증가, 번호 부여
//   2) 기본생성자 : Stuscore(){}
//   3) 오버로딩 생성자
//   4) 변수 : 인스턴스변수(static) - 학생수  
//            클래스변수(private) - 번호, 이름, 국어, 영어, 수학, 합계, 평균
//   5) 자동 메서드 생성 : source -> generate getter and setter -> select All
// 2> StuDeck 클래스 정의
// 3> C08.java에서 main 작성
//   1)
//   1)
// 
// 
// 
// C08 - case 입력
// stuDeck - void 추가, 출력
// 
//==============================================
// [ 학생 성적 처리 ] 
// 1. Stuscore.java
// 2. C03
//    public static void main(String[] args) {
//       Scanner scan = new Scanner(System.in);
//       int choice = scan.nextInt();
// 3. StuDeck.java
//    1) 화면출력
//    2) 배열 : 객체선언
//    3) 성적입력 stu_input
// 4. C03
//    1) case 1 부분 : 1번을 눌렀을때 : s.stu_input(); 으로 성적입력
// 5. Stuscore.java
//    1) String[] title > 테이블 제목 배열
//    2) 성적출력 stu_output
// 
// 
// 
// 
// 
// 
//==============================================
//
// [ 카드 게임 만들기 ]
// 1> main에서만 작성 (가능하지만 비효율적)
// 1) Card 객체선언
// 2) 카드 모양 : SPADE, HEART, DIAMOND, CLOVER
// 3) Deck 객체선언
// 4) N장의 카드 출력
// ------------------
// 2> main과 Card,Deck 클래스 분리
// 1. Card 클래스 정의 
//    - 카드번호 (int number;) / 카드모양 (String kind;)
// 2. Deck 클래스 정의
// 3. main에서 Deck 객체선언
// 3-1. 5장의 카드 뽑기 (card5Print)
// 3-2. 카드 섞기 (shuffle)
// 3-3. 랜덤 카드 5장 출력 (card5Random)
//
//==============================================

